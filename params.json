{"name":"Cwilcox13.github.io","tagline":"This is a blog about things I am learning during my internship at Frontleaf, a web application startup in Oakland.","body":"One of the many important things I am learning as an intern at Frontleaf is about AngularJS. AngularJS is a JavaScript library that allows developers to configure HTML to change dynamically according to specific data; this makes it very suitable for web applications.\r\n\r\nA significant aspect of AngularJS is routing. Routing allows you to have multiple views on your web application. This behaves much like clicking a hyperlink on a regular web page; however, in Angular, clicking a link may take you to another view, but the web page itself will not reload. Any views having to do with your web application are already loaded, and will be served up whenever they are called. These different views are called routes in Angular, and the general way to implement these routes is with the $routeProvider. However, I have been learning about another way to implement routes called ui-router.\r\n\r\nUi-router works by using the $stateProvider instead of the $routeProvider. A state is essentially a spot or an area in your web page that you can get to through navigation of the UI. A state describes what that specific area looks like, and what it does. An important feature of states is that they can be nested, which I will discuss later. \r\n\r\nIn order to start working with states, we have to do a few things. First, we have to include the ui-view attribute in our HTML, like this:\r\n\r\n\t<div ui-view></div>\r\n\r\nThis will cause any different states that we have to show up in this div automatically. \r\n\r\nNext, we need to include our $stateProvider in our .js file corresponding to our HTML. The $stateProvider will basically tell us what states that we have. Here is one of the easiest ways to do this:\r\n\r\n\t$stateProvider.state('stateName', {\r\n\t\ttemplateUrl: 'state.html'\r\n\t}); \r\n\r\nIn this command, we add a new state, give it a name ('stateName'), and tell the state where to go ('state.html'). This is called setting the template. Basically, this tells us that when the state changes to 'stateName', then state.html will be inserted into the ui-view div that we created earlier. Because of this, state.html is what is known as a 'partial'. We can also set the template by calling a function that returns a url, or by simply writing HTML directly into the $stateProvider. We can create many different states in this way if we wish to. \r\n\r\nAnother way we can deal with creating states is to first create them as objects, then use $stateProvider, like this:\r\n\r\n\tvar state1 = {\r\n\t\tname: 'state1',\r\n\t\ttemplateUrl: 'state1.html'\r\n\t}\r\n\r\n\t$stateProvider.state(state1);\r\n\r\nThis does the same thing as before, but shows another way to do it. Keep in mind that if you do it this way, you have to specify the 'parent:' property of any child states you create. We will discuss parent states in a bit.\r\n\r\nOne of the main points of the $stateProvider is that we can make different parts of our web application change without making the whole page change. Right now, we have a state and a div in which to put the state, but how do we actually get it to change? Here's how:\r\n\r\n\tfunction MyController($state){\r\n\t\t$state.transitionTo('stateName')\r\n\t};\r\n\r\nWe can add a controller that uses the command $state.transitionTo(). This tells the $stateProvider to change the state to whatever is included as a parameter. We can also set the $state.transitionTo() command to happen on certain events, such as when a specific button is clicked. \r\n\r\nHowever, this won't work yet. First, we need to specify the controller that is used by the 'stateName' state:\r\n\r\n\t\t$stateProvider.state('stateName', {\r\n\t\t\ttemplateUrl: 'state.html'\r\n\t\t\tcontroller: 'MyController'\r\n\t\t});\r\n\r\nNow we have a state, a place for the state to go, and a controller for the state.\r\n\r\nAnother important thing we can add to our $stateProvider is resolve. Resolve allows us to add data to a state that is specific to that particular state. This data may be dependent on data and functions outside the state, but once it is resolved for a particular state, it can be used in that state and in any of its child states. You can add resolve like this:\r\n\r\n\t\t$stateProvider.state('stateName', {\r\n\t\t\ttemplateUrl: 'state.html'\r\n\t\t\tcontroller: 'MyController'\r\n\t\t\tresolve: {stateData: \"This is a state\"}\r\n\t\t});\r\n\r\nThis provides a variable called stateData to stateName that holds the string \"This is a state\".\r\n\r\nAs I mentioned before, you can nest states within each other. One easy way to do this is with dot syntax:\r\n\r\n\t$stateProvider\r\n\t\t.state('state1',{})\r\n\t\t.state('state1.state1a',{});\r\n\r\nThis makes state1a the child of state1. You can also use the parent attribute:\r\n\r\n\t$stateProvider\r\n\t\t.state('state1',{})\r\n\t\t.state('state1a',{\r\n\t\t\tparent: 'state1'\r\n\t\t});\r\n\r\nThis does the same thing as the piece of code above. Remember that if we declare our states as objects first, we MUST include the parent property. \r\n\r\nSo how do nested states actually work? When a state has been transitioned to, it is current, or active. If the current state is a child state, that means its parent is also active at the same time. A child state will load whatever template it has set into its parent's ui-view, which means that any parent state must have a ui-view set in their template. A child state will also inherit properties from its parent state. It is possible to create something called an abstract state, which is a state that will not actually ever be transitioned to, but is simply there to provide properties to a group of common child states. \r\n\r\nKeep in mind that objects that are resolved in the controller for a parent state will be inherited by the child states. So you should make sure not to change a parent's object in any way that will not work for a child. For example:\r\n\r\n\tattr.name = \"data.\" + attr.name\r\n\r\nThis may be a way we modify attr.name in a parent state. But if the child state expects the attr.name without the \"data.\" in front of it, it will not run correctly.\r\n\r\nIt is also possible to create more than one view per state. For example, if you had two different areas on your web application that you needed to correspond to one particular state, you could create views for each of them, which would correspond to your state but also have different templates. In order to do this, we would have to create two ui-views in our original HTML:\r\n\r\n\t<div ui-view=\"window1\"></div>\r\n\t<div ui-view=\"window2\"></div>\r\n\r\nThen, we can add a 'views' attribute in our $stateProvider:\r\n\r\n\t$stateProvider.state('myState'{\r\n\t\tviews: {\r\n\t\t\t'window1': {\r\n\t\t\t\ttemplateUrl: 'window1.html'\r\n\t\t\t\tcontroller: 'Window1Controller'\r\n\t\t\t},\r\n\t\t\t'window2': {\r\n\t\t\t\ttemplateUrl: 'window2.html'\r\n\t\t\t\tcontroller: 'Window2Controller'\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\nThe 'views' attribute lets us specify what will be inserted into each of our ui-views. the name of the ui-view and the name of the corresponding view in the $stateProvider must be the same, so Angular will know how to match them. Then each view can have its own template, controller, and so on.\r\n\r\nAnother important part of ui-router is being able to set URLs for specific views. This can be done by using the url property:\r\n\r\n\t$stateProvider.state('myState',{\r\n\t\turl: \"/mystate\"\r\n\t\ttemplateUrl: 'myState.html'\r\n\t});\r\n\r\nHere we set the URL that the web application will be directed to when myState is active. It will also cause myState to be active if you type in this URL. This URL is a continuation of whatever the ancestor HTML page is called; for example, if it was called index.html, the full URL would be index.html/mystate. In fact, a child state will combine their url with the url of its parent state. So, if we had a home page called index.html, a state with url: '/mystate', and a child state of that with url: '/childstate', then the full URL if the child state was active would be index.html/mystate/childstate.\r\n\r\nI think it is important to note the difference between url and templateUrl. url is the actual URL corresponding to the state you are in, and templateUrl is the template .html file that is inserted into your ui-view.\r\n\r\nSometimes URLs have parameters in them. To specify a parameter in your url property, you can just add a colon, like this:\r\n\r\n\turl: \"/mystate/:id\"\r\n\r\nThis allows your URL to direct to a specific URL dependent on that dynamic parameter.\r\n\r\nThe things I've discussed here are just some of the basics of ui-router. It is a very elegant way to provide different ways of interacting and viewing your web application. There is more information on ui-router at github.com/angular-ui/ui-router.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}