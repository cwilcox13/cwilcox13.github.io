{"name":"Curtis's Frontleaf Blog","tagline":"This is a blog about things I am learning during my internship at Frontleaf, a web application startup in Oakland.","body":"# July 11, 2013\r\n\r\nAs an intern at Frontleaf, I am learning a lot; one of the extremely important things I am learning about is unit testing. As a computer engineering major, I have learned what unit testing is, but I have never really had any experience in how to actually go about writing and running unit tests. It is a very useful skill to know, and it is quite helpful when developing a project.\r\n\r\nA unit test is developed in order to test a specific piece of functionality in your project. It is basically a piece of code that runs this functionality in order to very that your code is working the way it is supposed to. This is in contrast to something like an integration test or an end-to-end test, which would test a larger part, or even all, of your code to make sure each component is working correctly with the others. Unit tests are specifically for one small feature; for example, I recently wrote a unit test (albeit not in the format we will be discussing in this piece) to verify that a percent sign '%' would be added on to specific types in my HTML table. Not a huge deal, but useful in that it makes sure that my code does what I want it to do, and it will continue to do so even if I make modifications to that code or code somewhere else in my program. It is also a time saver; instead of manually testing things after I make changes, I simply have to run the unit test I have created.\r\n\r\nThere are different ways to create unit tests depending on what language you are writing in. The first type of unit testing we will look at is called JUnit. This is a unit testing framework for the Java programming language. It is something that I have begun to learn about, as some of my programming is done in Java. JUnit is nice to use in a Java IDE like Eclipse, which I will be assuming we are using in this piece.\r\n\r\nTypically, JUnit tests should be created in a separate package or source folder from the actual parts of the program. This makes it easier to manage since they are separate from the actual code. \r\n\r\nIn order to create JUnit tests, we should create a class to hold these tests. This class should be created separately from any classes in the source code and should be used only for testing purposes. This is called a test class. Test classes can be created in a couple of different ways. One way is to simply create the test class manually. Another way is to create the test class using a JUnit wizard under File->New->Other->Java->Unit. A third way is to simply right-click on a package or class in your package explorer view in Eclipse, and select New->JUnit Test Case. \r\n\r\nAfter we create our test class, we can add test methods to our test class. A test method typically corresponds to a unit test. However, there are a couple specific things that need to be included in the test method for JUnit to recognize it as a unit test. Here is a very simple example of a JUnit test:\r\n\r\n\t@Test\r\n\tpublic void myTest(){\r\n\t\tClass1 newClass = new Class1();\r\n\t\tassertEquals(\"should return 1\", 1, newClass.method1());\r\n\t} \r\n\r\nFirst, let's note the annotation '@Test' at the beginning. This tells JUnit that the method following the @Test annotation will be a test method. There are other annotations as well, which I will go into shortly. Next, notice that the test method is written much like a regular method would be. Finally, let's note the 'assertEquals()' at the end of the method. This is a JUnit assert statement. Assert statements are provided by JUnit to allow you to check for certain conditions in your test method. We will go into these shortly as well.  \r\n\r\nNow that we have seen a simple test method, let's look at some of the annotations for JUnit. Remember, annotations are put at the beginning of a test method in order to tell JUnit what kind of test method it is.\r\n\r\n@Test says it is a regular test method, and the method must be public void. \r\n\r\n@Before denotes a method that should be done before each test method. This can be used to initialize classes or any data that needs to be ready for the actual test method. A @Before method must be public void. \r\n\r\n@After denotes a method that should be done after each test method. This can be used to delete any data that needs to be cleaned up after a test method runs. This must also be public void.\r\n\r\nThere are other annotations as well, but these three are a good starting point for learning about JUnit.\r\n\r\nNow let's take a look at some of the JUnit assert statements. Remember, assert statements are JUnit's way of helping us ensure that our test methods are running correctly. These usually start with 'assert' and then let you add an error message, an expected result, and the variable or function that will return the actual result. This allows us to compare the expected result with the actual result. It is important to note the importance of error messages; the more specific the error message, the easier it may be for a debugger to figure out what the error actually is in your code. Here are a couple of probably the most commonly used assert statements.\r\n\r\nassertEquals(\"error message\",expected,actual); This will allow us to take an actual value and determine whether it is equal to our expected value, or what we want. If it is not, it will give us the error message. \r\nassertTrue(\"error message\",boolean); This will allow us to ensure that a specific boolean condition we are checking for is true.\r\n\r\nassertNull/assertNotNull(\"error message\",object); This will allow us to see whether some sort of object is null or not.\r\n\r\nThere are other assert statements as well, but these are a good starting point.\r\n\r\nSo how do we actually run a test class? In order to do this in Eclipse, all you have to do is right-click on the test class, either in the package explorer or in your program window, and select Run->Run As->JUint Test. This will run all the test methods in your test class and tell you the results. Your results are shown to you in something called the JUnit view, which can either show up in its own window or as another tab next to the package explorer. You can view test failures and successes and rerun tests in this view. You can also edit this view to only show failing tests, if you wish. If any methods in the test class fail, a red bar will appear. If all the methods pass, a green bar will appear. If we see green, we know that our tests are working correctly, and can take ease in the fact that if we use this feature somewhere else, it will work as it should. \r\n\r\nOne thing we haven't gone through yet is how to import all of these different portions of JUnit into our test classes. Do do this, we need to import packages starting with 'org.junit'. Different assertion statements need to be imported as static, like this: 'import static org.junit.Assert.assertEquals'. Different test annotations must be imported like this: 'import org.junit.Test'. Obviously, in order to be able to use specific annotations and assertion statements, you must import the corresponding packages.\r\n\r\nAnother interesting thing about JUnit is the ability to use rules in your test methods. To do this, we implement the @Rule annotation in front of any rules we create. Rules can simply be objects that you create in order to use them or change them during the course of your test method.\r\n\r\nThere may be instances where you have many test classes, with one or multiple test methods in them. If this is the case, you may want to run all of these classes at once, for one reason or another. If you do, you can create a test suite that holds all these different test classes. If you run an entire test suite, it will run all the test classes, and in turn, all the test methods, contained within it. To create a test suite, we must first import certain packages:\r\n\r\n\timport org.junit.runner.RunWith;\r\n\timport org.junit.runners.Suite;\r\n\timport org.junit.runners.Suite.SuiteClasses;\r\n\r\nNext, we have to make certain annotations:\r\n\r\n\t@RunWith(Suite.class)\r\n\t@SuiteClasses({class1.class, class2.class})\r\n\r\nThis specifies that class1 and class2 are both included in the test suite. \r\n\r\nAnother important feature to note about JUnit is the order in which tests are executed. Test methods in a test class are executed in a fairly random order, which means that you should not create tests that are dependent on other tests, or they may not work correctly.\r\n\r\nWhat if we want to test our exceptions? Sometimes if something happens that is not allowed in our program, we will make it throw an exception; this tells the user or developer that they cannot do what they tried to do. It is important to make sure that these exceptions happen correctly as well, so we can write unit tests for them. We can do that by using the 'expected' parameter:\r\n\r\n\t@Test(expected = someException)\r\n\tpublic void test1()...\r\n\r\nThe expected parameter tells JUnit that we are expecting some sort of exception to be thrown as this test is executed. 'someException' would obviously have to be replaced by whatever type of exception you are expecting to receive, such as IndexOutOfBoundsException.class. If this exception happens anywhere in your test, then the test will pass. If the exception does not happen anywhere in the test, the test will fail.\r\n\r\nJUnit tests are very useful when working with Eclipse; they allow a developer to more easily and thoroughly check their code to make sure it is working correctly. It is important to note the importance of actually writing tests for various features of your code. It is one thing to know how to write tests, and it is another to actually go about the practice of doing it. It can really help in the long run.\r\n\r\n# July 11, 2013\r\n\r\nOne of the many important things I am learning as an intern at Frontleaf is about AngularJS. AngularJS is a JavaScript library that allows developers to configure HTML to change dynamically according to specific data; this makes it very suitable for web applications.\r\n\r\nA significant aspect of AngularJS is routing. Routing allows you to have multiple views on your web application. This behaves much like clicking a hyperlink on a regular web page; however, in Angular, clicking a link may take you to another view, but the web page itself will not reload. Any views having to do with your web application are already loaded, and will be served up whenever they are called. These different views are called routes in Angular, and the general way to implement these routes is with the $routeProvider. However, I have been learning about another way to implement routes called ui-router.\r\n\r\nUi-router works by using the $stateProvider instead of the $routeProvider. A state is essentially a spot or an area in your web page that you can get to through navigation of the UI. A state describes what that specific area looks like, and what it does. An important feature of states is that they can be nested, which I will discuss later. \r\n\r\nIn order to start working with states, we have to do a few things. First, we have to include the ui-view attribute in our HTML, like this:\r\n\r\n\t<div ui-view></div>\r\n\r\nThis will cause any different states that we have to show up in this div automatically. \r\n\r\nNext, we need to include our $stateProvider in our .js file corresponding to our HTML. The $stateProvider will basically tell us what states that we have. Here is one of the easiest ways to do this:\r\n\r\n\t$stateProvider.state('stateName', {\r\n\t\ttemplateUrl: 'state.html'\r\n\t}); \r\n\r\nIn this command, we add a new state, give it a name ('stateName'), and tell the state where to go ('state.html'). This is called setting the template. Basically, this tells us that when the state changes to 'stateName', then state.html will be inserted into the ui-view div that we created earlier. Because of this, state.html is what is known as a 'partial'. We can also set the template by calling a function that returns a url, or by simply writing HTML directly into the $stateProvider. We can create many different states in this way if we wish to. \r\n\r\nAnother way we can deal with creating states is to first create them as objects, then use $stateProvider, like this:\r\n\r\n\tvar state1 = {\r\n\t\tname: 'state1',\r\n\t\ttemplateUrl: 'state1.html'\r\n\t}\r\n\r\n\t$stateProvider.state(state1);\r\n\r\nThis does the same thing as before, but shows another way to do it. Keep in mind that if you do it this way, you have to specify the 'parent:' property of any child states you create. We will discuss parent states in a bit.\r\n\r\nOne of the main points of the $stateProvider is that we can make different parts of our web application change without making the whole page change. Right now, we have a state and a div in which to put the state, but how do we actually get it to change? Here's how:\r\n\r\n\tfunction MyController($state){\r\n\t\t$state.transitionTo('stateName')\r\n\t};\r\n\r\nWe can add a controller that uses the command $state.transitionTo(). This tells the $stateProvider to change the state to whatever is included as a parameter. We can also set the $state.transitionTo() command to happen on certain events, such as when a specific button is clicked. \r\n\r\nHowever, this won't work yet. First, we need to specify the controller that is used by the 'stateName' state:\r\n\r\n\t\t$stateProvider.state('stateName', {\r\n\t\t\ttemplateUrl: 'state.html'\r\n\t\t\tcontroller: 'MyController'\r\n\t\t});\r\n\r\nNow we have a state, a place for the state to go, and a controller for the state.\r\n\r\nAnother important thing we can add to our $stateProvider is resolve. Resolve allows us to add data to a state that is specific to that particular state. This data may be dependent on data and functions outside the state, but once it is resolved for a particular state, it can be used in that state and in any of its child states. You can add resolve like this:\r\n\r\n\t\t$stateProvider.state('stateName', {\r\n\t\t\ttemplateUrl: 'state.html'\r\n\t\t\tcontroller: 'MyController'\r\n\t\t\tresolve: {stateData: \"This is a state\"}\r\n\t\t});\r\n\r\nThis provides a variable called stateData to stateName that holds the string \"This is a state\".\r\n\r\nAs I mentioned before, you can nest states within each other. One easy way to do this is with dot syntax:\r\n\r\n\t$stateProvider\r\n\t\t.state('state1',{})\r\n\t\t.state('state1.state1a',{});\r\n\r\nThis makes state1a the child of state1. You can also use the parent attribute:\r\n\r\n\t$stateProvider\r\n\t\t.state('state1',{})\r\n\t\t.state('state1a',{\r\n\t\t\tparent: 'state1'\r\n\t\t});\r\n\r\nThis does the same thing as the piece of code above. Remember that if we declare our states as objects first, we MUST include the parent property. \r\n\r\nSo how do nested states actually work? When a state has been transitioned to, it is current, or active. If the current state is a child state, that means its parent is also active at the same time. A child state will load whatever template it has set into its parent's ui-view, which means that any parent state must have a ui-view set in their template. A child state will also inherit properties from its parent state. It is possible to create something called an abstract state, which is a state that will not actually ever be transitioned to, but is simply there to provide properties to a group of common child states. \r\n\r\nKeep in mind that objects that are resolved in the controller for a parent state will be inherited by the child states. So you should make sure not to change a parent's object in any way that will not work for a child. For example:\r\n\r\n\tattr.name = \"data.\" + attr.name\r\n\r\nThis may be a way we modify attr.name in a parent state. But if the child state expects the attr.name without the \"data.\" in front of it, it will not run correctly.\r\n\r\nIt is also possible to create more than one view per state. For example, if you had two different areas on your web application that you needed to correspond to one particular state, you could create views for each of them, which would correspond to your state but also have different templates. In order to do this, we would have to create two ui-views in our original HTML:\r\n\r\n\t<div ui-view=\"window1\"></div>\r\n\t<div ui-view=\"window2\"></div>\r\n\r\nThen, we can add a 'views' attribute in our $stateProvider:\r\n\r\n\t$stateProvider.state('myState'{\r\n\t\tviews: {\r\n\t\t\t'window1': {\r\n\t\t\t\ttemplateUrl: 'window1.html'\r\n\t\t\t\tcontroller: 'Window1Controller'\r\n\t\t\t},\r\n\t\t\t'window2': {\r\n\t\t\t\ttemplateUrl: 'window2.html'\r\n\t\t\t\tcontroller: 'Window2Controller'\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\nThe 'views' attribute lets us specify what will be inserted into each of our ui-views. the name of the ui-view and the name of the corresponding view in the $stateProvider must be the same, so Angular will know how to match them. Then each view can have its own template, controller, and so on.\r\n\r\nAnother important part of ui-router is being able to set URLs for specific views. This can be done by using the url property:\r\n\r\n\t$stateProvider.state('myState',{\r\n\t\turl: \"/mystate\"\r\n\t\ttemplateUrl: 'myState.html'\r\n\t});\r\n\r\nHere we set the URL that the web application will be directed to when myState is active. It will also cause myState to be active if you type in this URL. This URL is a continuation of whatever the ancestor HTML page is called; for example, if it was called index.html, the full URL would be index.html/mystate. In fact, a child state will combine their url with the url of its parent state. So, if we had a home page called index.html, a state with url: '/mystate', and a child state of that with url: '/childstate', then the full URL if the child state was active would be index.html/mystate/childstate.\r\n\r\nI think it is important to note the difference between url and templateUrl. url is the actual URL corresponding to the state you are in, and templateUrl is the template .html file that is inserted into your ui-view.\r\n\r\nSometimes URLs have parameters in them. To specify a parameter in your url property, you can just add a colon, like this:\r\n\r\n\turl: \"/mystate/:id\"\r\n\r\nThis allows your URL to direct to a specific URL dependent on that dynamic parameter.\r\n\r\nThe things I've discussed here are just some of the basics of ui-router. It is a very elegant way to provide different ways of interacting and viewing your web application. There is more information on ui-router at github.com/angular-ui/ui-router.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}