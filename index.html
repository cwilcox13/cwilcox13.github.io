<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Curtis's Frontleaf Blog : This is a blog about things I am learning during my internship at Frontleaf, a web application startup in Oakland specializing in driving customer value for SaaS companies. Want to learn more? Interested in an engineering position? Check out www.frontleaf.com!" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Curtis's Frontleaf Blog</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/cwilcox13">View on GitHub</a>

          <h1 id="project_title">Curtis's Frontleaf Blog</h1>
          <h2 id="project_tagline">This is a blog about things I am learning during my internship at Frontleaf, a web application startup in Oakland specializing in driving customer value for SaaS companies. Want to learn more? Interested in an engineering position? Check out www.frontleaf.com!</h2>

        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="august-12-2013" class="anchor" href="#august-12-2013"><span class="octicon octicon-link"></span></a>August 12, 2013</h1>

<p>As I stated before in my JUnit piece, I am learning a lot about unit testing here at Frontleaf. Unit testing is very convenient when you actually know how to do it, and when you actually put it into practice. JUnit is a unit testing framework specifically for Java. However, most of my work involves JavaScript (more specifically, CoffeeScript, but still), which means it is in my best interests to learn how to perform unit tests in JavaScript as well as Java. </p>

<p>At Frontleaf, we are using the Jasmine framework for unit testing in JavaScript. Jasmine is an automated testing framework for the JavaScript programming language. One thing it is designed for is to make it easier to create and run unit tests in your JavaScript applications. </p>

<p>Jasmine makes it easy to test features or functions in your program. For instance, imagine you have a simple function like this:</p>

<pre><code>function myFunction(){
    return 1
}
</code></pre>

<p>Now imagine we would like to test this function using Jasmine:</p>

<pre><code>describe('mySuite', function(){
    it('should return 1', function(){
        expect(myFunction()).toEqual(1);
    });
});
</code></pre>

<p>Let's take a look at each part of this code. First, we have a describe() function. This is called a suite. It basically describes the group of unit tests that you are performing, which allows you to group them in specific ways. The unit tests are outlined in an anonymous function inside of the suite. describe() also gives the suite a name, which in this case is 'mySuite'. Not very descriptive, but this is just an example. Inside this first anonymous function, we have the it() function. This is called a spec. This is basically where a specific unit test will be happening. You can have multiple specs in your test suite, so we could do something like this if we wanted:</p>

<pre><code>describe('mySuite',function(){
    it('should return 1', function(){
        expect(myFunction()).toEqual(1);
    });
    it('should return 2', function(){
        expect(myFunction2()).toEqual(2);
    });
});
</code></pre>

<p>This would provide tests for myFunction and another function that we haven't actually defined here called myFunction2. Each spec provides a description of the unit test, along with another anonymous function. This final anonymous function is where we actually run the unit test. Notice we have an expect() function in here. This is basically a way for us to check whether our test performs correctly. It is somewhat like an assertion statement in JUnit testing. If we say expect(myFunction()).toEqual(1), we are saying that we expect myFunction, when it executes, to return 1. There are many more things that you can do inside the spec, which we will go into.</p>

<p>The actual unit tests for Jasmine should be kept in separate files from the source code that we are testing. In order to allow these files to collaborate with each other, we can create a test .html file and include both the source .js files and the test .js files in it.</p>

<p>Remember our expect() statement from earlier; it included a toEqual() function. This toEqual() function is called a matcher in Jasmine. We can use matchers inside our expect() statement in order to specifically define what we expect our resulting test data to look like or how we expect it to behave. Jasmine includes many other different kinds of matchers that we can use, such as 'toBeDefined' (makes sure something is defined), 'toBeNull' (makes sure something is null), 'toBeTruthy' (makes sure a boolean value is true), 'toBeLessThan' (makes sure a value is less than another value), 'toContain' (makes sure an object contains a specific value or object), among others. This gives us a lot of different types of tests we can work with. </p>

<p>What if you want to write a test and you can't find a good matcher for it? You can actually write your own matchers if you wish to. A good practice is to create your matcher using the beforeEach() statement, which causes anything inside it to occur before each test you write (there is also an afterEach() statement that you can use to make things occur after your tests, such as data cleanup). That way, you can have the matcher created for any test. This is what it might look like if I wanted to make a matcher that checked whether a string was a certain length:</p>

<pre><code>beforeEach(function(){
    this.addMatchers({
        toBeTwoChars: function(){
            return (this.actual.length == 2)
        }
    });
});
</code></pre>

<p>As you can see, we use the beforeEach() function, and inside it, we call this.addMatchers, which lets us...add matchers. I name my matcher toBeTwoChars, and then I create a function that actually checks whether whatever is passed into toBeTwoChars is two characters long. I use this.actual because I am checking the actual content of the object I am passing in. I can then use this matcher like a regular one:</p>

<pre><code>it('is to chars long', function(){
    expect('hi').toBeTwoChars();
});
</code></pre>

<p>Another cool part of Jasmine is the ability to use spies in your tests. A spy is basically part of your test that allows you to watch certain parts of your program to see what they do or how they act.</p>

<p>If we have a function that calls another function, we can put a spy in it to make sure that it calls the other function correctly. Here is an example:</p>

<pre><code>var Obj = function() {};

Obj.Function1 = function(word){
    return this.Function2 + word; 
};

Obj.Function2 = function(){
    return "The word is ";
};

describe("mySuite", function(){
    it("calls Function2()", function(){
        var myObject = new Obj();
        spyOn(myObject,"Function2");
        myObject.Function1("apple");
        expect(myObject.Function2).toHaveBeenCalled();
    });
}); 
</code></pre>

<p>So what is happening here? First, we are defining an object called Obj. Then, we are creating two functions that Obj can use: Function1 and Function2. As you can see, Function1 is actually calling Function2. This is what we want to test. So the next piece is to use a describe() function to create a test. Inside the describe(), we create a new Obj to test with. Then, we run spyOn(myObject,"Function2"); this will watch the Function2() method in the Obj we just created. Then, we run Function1() of the Obj, and we tell our test to expect that Function2() should have been called. Essentially, we are running Function1, but watching Function2 to make sure it is called as well. What if we want to make sure that Function1 is called with a specific argument (which in our case is "apple")? We can do that by changing our spy to:</p>

<pre><code>spyOn(myObject,"Function1");
</code></pre>

<p>And then changing our expect() to:</p>

<pre><code>expect(myObject.Function1).toHaveBeenCalledWith("apple");
</code></pre>

<p>Finally, we will look at some asynchronous testing. There are two main functions that help with asynchronous testing. The first one is runs(). If you put code in runs() functions, it just executes procedurally, so your code will run the way you write it.</p>

<p>The second function is called waitsFor(). The waitsFor() function allows you to specifically wait until a certain condition is true before continuing on with your code. This is helpful when things are running asynchronously and you want to make sure your code is executing in the correct order and with the proper timing.</p>

<p>These are some of the main aspects of Jasmine testing. Again, this is very useful for testing things in JavaScript, which is one of the languages I am using the most here at Frontleaf.</p>

<h1>
<a name="july-11-2013" class="anchor" href="#july-11-2013"><span class="octicon octicon-link"></span></a>July 11, 2013</h1>

<p>As an intern at Frontleaf, I am learning a lot; one of the extremely important things I am learning about is unit testing. As a computer engineering major, I have learned what unit testing is, but I have never really had any experience in how to actually go about writing and running unit tests. It is a very useful skill to know, and it is quite helpful when developing a project.</p>

<p>A unit test is developed in order to test a specific piece of functionality in your project. It is basically a piece of code that runs this functionality in order to very that your code is working the way it is supposed to. This is in contrast to something like an integration test or an end-to-end test, which would test a larger part, or even all, of your code to make sure each component is working correctly with the others. Unit tests are specifically for one small feature; for example, I recently wrote a unit test (albeit not in the format we will be discussing in this piece) to verify that a percent sign '%' would be added on to specific types in my HTML table. Not a huge deal, but useful in that it makes sure that my code does what I want it to do, and it will continue to do so even if I make modifications to that code or code somewhere else in my program. It is also a time saver; instead of manually testing things after I make changes, I simply have to run the unit test I have created.</p>

<p>There are different ways to create unit tests depending on what language you are writing in. The first type of unit testing we will look at is called JUnit. This is a unit testing framework for the Java programming language. It is something that I have begun to learn about, as some of my programming is done in Java. JUnit is nice to use in a Java IDE like Eclipse, which I will be assuming we are using in this piece.</p>

<p>Typically, JUnit tests should be created in a separate package or source folder from the actual parts of the program. This makes it easier to manage since they are separate from the actual code. </p>

<p>In order to create JUnit tests, we should create a class to hold these tests. This class should be created separately from any classes in the source code and should be used only for testing purposes. This is called a test class. Test classes can be created in a couple of different ways. One way is to simply create the test class manually. Another way is to create the test class using a JUnit wizard under File-&gt;New-&gt;Other-&gt;Java-&gt;Unit. A third way is to simply right-click on a package or class in your package explorer view in Eclipse, and select New-&gt;JUnit Test Case. </p>

<p>After we create our test class, we can add test methods to our test class. A test method typically corresponds to a unit test. However, there are a couple specific things that need to be included in the test method for JUnit to recognize it as a unit test. Here is a very simple example of a JUnit test:</p>

<pre><code>@Test
public void myTest(){
    Class1 newClass = new Class1();
    assertEquals("should return 1", 1, newClass.method1());
} 
</code></pre>

<p>First, let's note the annotation '<a href="https://github.com/Test" class="user-mention">@Test</a>' at the beginning. This tells JUnit that the method following the <a href="https://github.com/Test" class="user-mention">@Test</a> annotation will be a test method. There are other annotations as well, which I will go into shortly. Next, notice that the test method is written much like a regular method would be. Finally, let's note the 'assertEquals()' at the end of the method. This is a JUnit assert statement. Assert statements are provided by JUnit to allow you to check for certain conditions in your test method. We will go into these shortly as well.  </p>

<p>Now that we have seen a simple test method, let's look at some of the annotations for JUnit. Remember, annotations are put at the beginning of a test method in order to tell JUnit what kind of test method it is.</p>

<p><a href="https://github.com/Test" class="user-mention">@Test</a> says it is a regular test method, and the method must be public void. </p>

<p><a href="https://github.com/Before" class="user-mention">@Before</a> denotes a method that should be done before each test method. This can be used to initialize classes or any data that needs to be ready for the actual test method. A <a href="https://github.com/Before" class="user-mention">@Before</a> method must be public void. </p>

<p><a href="https://github.com/After" class="user-mention">@After</a> denotes a method that should be done after each test method. This can be used to delete any data that needs to be cleaned up after a test method runs. This must also be public void.</p>

<p>There are other annotations as well, but these three are a good starting point for learning about JUnit.</p>

<p>Now let's take a look at some of the JUnit assert statements. Remember, assert statements are JUnit's way of helping us ensure that our test methods are running correctly. These usually start with 'assert' and then let you add an error message, an expected result, and the variable or function that will return the actual result. This allows us to compare the expected result with the actual result. It is important to note the importance of error messages; the more specific the error message, the easier it may be for a debugger to figure out what the error actually is in your code. Here are a couple of probably the most commonly used assert statements.</p>

<p>assertEquals("error message",expected,actual); This will allow us to take an actual value and determine whether it is equal to our expected value, or what we want. If it is not, it will give us the error message. 
assertTrue("error message",boolean); This will allow us to ensure that a specific boolean condition we are checking for is true.</p>

<p>assertNull/assertNotNull("error message",object); This will allow us to see whether some sort of object is null or not.</p>

<p>There are other assert statements as well, but these are a good starting point.</p>

<p>So how do we actually run a test class? In order to do this in Eclipse, all you have to do is right-click on the test class, either in the package explorer or in your program window, and select Run-&gt;Run As-&gt;JUint Test. This will run all the test methods in your test class and tell you the results. Your results are shown to you in something called the JUnit view, which can either show up in its own window or as another tab next to the package explorer. You can view test failures and successes and rerun tests in this view. You can also edit this view to only show failing tests, if you wish. If any methods in the test class fail, a red bar will appear. If all the methods pass, a green bar will appear. If we see green, we know that our tests are working correctly, and can take ease in the fact that if we use this feature somewhere else, it will work as it should. </p>

<p>One thing we haven't gone through yet is how to import all of these different portions of JUnit into our test classes. Do do this, we need to import packages starting with 'org.junit'. Different assertion statements need to be imported as static, like this: 'import static org.junit.Assert.assertEquals'. Different test annotations must be imported like this: 'import org.junit.Test'. Obviously, in order to be able to use specific annotations and assertion statements, you must import the corresponding packages.</p>

<p>Another interesting thing about JUnit is the ability to use rules in your test methods. To do this, we implement the <a href="https://github.com/Rule" class="user-mention">@Rule</a> annotation in front of any rules we create. Rules can simply be objects that you create in order to use them or change them during the course of your test method.</p>

<p>There may be instances where you have many test classes, with one or multiple test methods in them. If this is the case, you may want to run all of these classes at once, for one reason or another. If you do, you can create a test suite that holds all these different test classes. If you run an entire test suite, it will run all the test classes, and in turn, all the test methods, contained within it. To create a test suite, we must first import certain packages:</p>

<pre><code>import org.junit.runner.RunWith;
import org.junit.runners.Suite;
import org.junit.runners.Suite.SuiteClasses;
</code></pre>

<p>Next, we have to make certain annotations:</p>

<pre><code>@RunWith(Suite.class)
@SuiteClasses({class1.class, class2.class})
</code></pre>

<p>This specifies that class1 and class2 are both included in the test suite. </p>

<p>Another important feature to note about JUnit is the order in which tests are executed. Test methods in a test class are executed in a fairly random order, which means that you should not create tests that are dependent on other tests, or they may not work correctly.</p>

<p>What if we want to test our exceptions? Sometimes if something happens that is not allowed in our program, we will make it throw an exception; this tells the user or developer that they cannot do what they tried to do. It is important to make sure that these exceptions happen correctly as well, so we can write unit tests for them. We can do that by using the 'expected' parameter:</p>

<pre><code>@Test(expected = someException)
public void test1()...
</code></pre>

<p>The expected parameter tells JUnit that we are expecting some sort of exception to be thrown as this test is executed. 'someException' would obviously have to be replaced by whatever type of exception you are expecting to receive, such as IndexOutOfBoundsException.class. If this exception happens anywhere in your test, then the test will pass. If the exception does not happen anywhere in the test, the test will fail.</p>

<p>JUnit tests are very useful when working with Eclipse; they allow a developer to more easily and thoroughly check their code to make sure it is working correctly. It is important to note the importance of actually writing tests for various features of your code. It is one thing to know how to write tests, and it is another to actually go about the practice of doing it. It can really help in the long run.</p>

<h1>
<a name="july-11-2013-1" class="anchor" href="#july-11-2013-1"><span class="octicon octicon-link"></span></a>July 11, 2013</h1>

<p>One of the many important things I am learning as an intern at Frontleaf is about AngularJS. AngularJS is a JavaScript library that allows developers to configure HTML to change dynamically according to specific data; this makes it very suitable for web applications.</p>

<p>A significant aspect of AngularJS is routing. Routing allows you to have multiple views on your web application. This behaves much like clicking a hyperlink on a regular web page; however, in Angular, clicking a link may take you to another view, but the web page itself will not reload. Any views having to do with your web application are already loaded, and will be served up whenever they are called. These different views are called routes in Angular, and the general way to implement these routes is with the $routeProvider. However, I have been learning about another way to implement routes called ui-router.</p>

<p>Ui-router works by using the $stateProvider instead of the $routeProvider. A state is essentially a spot or an area in your web page that you can get to through navigation of the UI. A state describes what that specific area looks like, and what it does. An important feature of states is that they can be nested, which I will discuss later. </p>

<p>In order to start working with states, we have to do a few things. First, we have to include the ui-view attribute in our HTML, like this:</p>

<pre><code>&lt;div ui-view&gt;&lt;/div&gt;
</code></pre>

<p>This will cause any different states that we have to show up in this div automatically. </p>

<p>Next, we need to include our $stateProvider in our .js file corresponding to our HTML. The $stateProvider will basically tell us what states that we have. Here is one of the easiest ways to do this:</p>

<pre><code>$stateProvider.state('stateName', {
    templateUrl: 'state.html'
}); 
</code></pre>

<p>In this command, we add a new state, give it a name ('stateName'), and tell the state where to go ('state.html'). This is called setting the template. Basically, this tells us that when the state changes to 'stateName', then state.html will be inserted into the ui-view div that we created earlier. Because of this, state.html is what is known as a 'partial'. We can also set the template by calling a function that returns a url, or by simply writing HTML directly into the $stateProvider. We can create many different states in this way if we wish to. </p>

<p>Another way we can deal with creating states is to first create them as objects, then use $stateProvider, like this:</p>

<pre><code>var state1 = {
    name: 'state1',
    templateUrl: 'state1.html'
}

$stateProvider.state(state1);
</code></pre>

<p>This does the same thing as before, but shows another way to do it. Keep in mind that if you do it this way, you have to specify the 'parent:' property of any child states you create. We will discuss parent states in a bit.</p>

<p>One of the main points of the $stateProvider is that we can make different parts of our web application change without making the whole page change. Right now, we have a state and a div in which to put the state, but how do we actually get it to change? Here's how:</p>

<pre><code>function MyController($state){
    $state.transitionTo('stateName')
};
</code></pre>

<p>We can add a controller that uses the command $state.transitionTo(). This tells the $stateProvider to change the state to whatever is included as a parameter. We can also set the $state.transitionTo() command to happen on certain events, such as when a specific button is clicked. </p>

<p>However, this won't work yet. First, we need to specify the controller that is used by the 'stateName' state:</p>

<pre><code>    $stateProvider.state('stateName', {
        templateUrl: 'state.html'
        controller: 'MyController'
    });
</code></pre>

<p>Now we have a state, a place for the state to go, and a controller for the state.</p>

<p>Another important thing we can add to our $stateProvider is resolve. Resolve allows us to add data to a state that is specific to that particular state. This data may be dependent on data and functions outside the state, but once it is resolved for a particular state, it can be used in that state and in any of its child states. You can add resolve like this:</p>

<pre><code>    $stateProvider.state('stateName', {
        templateUrl: 'state.html'
        controller: 'MyController'
        resolve: {stateData: "This is a state"}
    });
</code></pre>

<p>This provides a variable called stateData to stateName that holds the string "This is a state".</p>

<p>As I mentioned before, you can nest states within each other. One easy way to do this is with dot syntax:</p>

<pre><code>$stateProvider
    .state('state1',{})
    .state('state1.state1a',{});
</code></pre>

<p>This makes state1a the child of state1. You can also use the parent attribute:</p>

<pre><code>$stateProvider
    .state('state1',{})
    .state('state1a',{
        parent: 'state1'
    });
</code></pre>

<p>This does the same thing as the piece of code above. Remember that if we declare our states as objects first, we MUST include the parent property. </p>

<p>So how do nested states actually work? When a state has been transitioned to, it is current, or active. If the current state is a child state, that means its parent is also active at the same time. A child state will load whatever template it has set into its parent's ui-view, which means that any parent state must have a ui-view set in their template. A child state will also inherit properties from its parent state. It is possible to create something called an abstract state, which is a state that will not actually ever be transitioned to, but is simply there to provide properties to a group of common child states. </p>

<p>Keep in mind that objects that are resolved in the controller for a parent state will be inherited by the child states. So you should make sure not to change a parent's object in any way that will not work for a child. For example:</p>

<pre><code>attr.name = "data." + attr.name
</code></pre>

<p>This may be a way we modify attr.name in a parent state. But if the child state expects the attr.name without the "data." in front of it, it will not run correctly.</p>

<p>It is also possible to create more than one view per state. For example, if you had two different areas on your web application that you needed to correspond to one particular state, you could create views for each of them, which would correspond to your state but also have different templates. In order to do this, we would have to create two ui-views in our original HTML:</p>

<pre><code>&lt;div ui-view="window1"&gt;&lt;/div&gt;
&lt;div ui-view="window2"&gt;&lt;/div&gt;
</code></pre>

<p>Then, we can add a 'views' attribute in our $stateProvider:</p>

<pre><code>$stateProvider.state('myState'{
    views: {
        'window1': {
            templateUrl: 'window1.html'
            controller: 'Window1Controller'
        },
        'window2': {
            templateUrl: 'window2.html'
            controller: 'Window2Controller'
        }
    }
});
</code></pre>

<p>The 'views' attribute lets us specify what will be inserted into each of our ui-views. the name of the ui-view and the name of the corresponding view in the $stateProvider must be the same, so Angular will know how to match them. Then each view can have its own template, controller, and so on.</p>

<p>Another important part of ui-router is being able to set URLs for specific views. This can be done by using the url property:</p>

<pre><code>$stateProvider.state('myState',{
    url: "/mystate"
    templateUrl: 'myState.html'
});
</code></pre>

<p>Here we set the URL that the web application will be directed to when myState is active. It will also cause myState to be active if you type in this URL. This URL is a continuation of whatever the ancestor HTML page is called; for example, if it was called index.html, the full URL would be index.html/mystate. In fact, a child state will combine their url with the url of its parent state. So, if we had a home page called index.html, a state with url: '/mystate', and a child state of that with url: '/childstate', then the full URL if the child state was active would be index.html/mystate/childstate.</p>

<p>I think it is important to note the difference between url and templateUrl. url is the actual URL corresponding to the state you are in, and templateUrl is the template .html file that is inserted into your ui-view.</p>

<p>Sometimes URLs have parameters in them. To specify a parameter in your url property, you can just add a colon, like this:</p>

<pre><code>url: "/mystate/:id"
</code></pre>

<p>This allows your URL to direct to a specific URL dependent on that dynamic parameter.</p>

<p>The things I've discussed here are just some of the basics of ui-router. It is a very elegant way to provide different ways of interacting and viewing your web application. There is more information on ui-router at github.com/angular-ui/ui-router.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
